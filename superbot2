#!/bin/bash
# superbot2 — single entry point: launch orchestrator, update, or run setup
set -euo pipefail
shopt -s nullglob

export CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS=1

REPO_DIR="$(cd "$(dirname "$0")" && pwd)"
SUPERBOT2_NAME="${SUPERBOT2_NAME:-superbot2}"
DIR="${SUPERBOT2_HOME:-$HOME/.$SUPERBOT2_NAME}"
export SUPERBOT2_HOME="$DIR"
export SUPERBOT2_NAME
CLAUDE_DIR="$DIR/.claude"
export CLAUDE_CONFIG_DIR="$CLAUDE_DIR"
TEAM_DIR="$CLAUDE_DIR/teams/$SUPERBOT2_NAME"
TEMPLATE="$DIR/templates/orchestrator-system-prompt-override.md"
RESTART_FLAG="$DIR/.restart"
LAUNCHER_PID=$$
LAUNCHER_PID_FILE="$DIR/.launcher.pid"

# ─── Single-instance guard ───
# If another launcher is already running, kill it before starting a new one.
# This prevents duplicate iMessage sends, duplicate heartbeat triggers, etc.
if [[ -f "$LAUNCHER_PID_FILE" ]]; then
  OLD_PID=$(cat "$LAUNCHER_PID_FILE" 2>/dev/null || echo "")
  if [[ -n "$OLD_PID" ]] && [[ "$OLD_PID" != "$$" ]] && kill -0 "$OLD_PID" 2>/dev/null; then
    echo "Found existing superbot2 launcher (PID $OLD_PID). Stopping it..."
    # Kill the old launcher and all its child processes (claude, dashboard, watchdog)
    pkill -TERM -P "$OLD_PID" 2>/dev/null || true
    kill -TERM "$OLD_PID" 2>/dev/null || true
    sleep 2
    # Force kill if still alive
    kill -9 "$OLD_PID" 2>/dev/null || true
    echo "Old launcher stopped."
  fi
fi

echo "$LAUNCHER_PID" > "$LAUNCHER_PID_FILE"
DASHBOARD_UI_PID=""

# ─── Dashboard UI ───

start_dashboard_ui() {
  local ui_dir="$REPO_DIR/dashboard-ui"
  if [[ ! -d "$ui_dir" ]]; then
    echo "Dashboard UI not found at $ui_dir — skipping"
    return
  fi

  # Kill any existing processes on both ports (e.g., from setup.sh or previous run)
  # so we always start fresh. Port 3274 = API server, port 5173 = vite dev server.
  for port in 3274 5173; do
    if lsof -ti:$port -sTCP:LISTEN &>/dev/null; then
      echo "Stopping existing process on port $port..."
      lsof -ti:$port -sTCP:LISTEN | xargs kill 2>/dev/null || true
      for i in {1..20}; do
        lsof -ti:$port -sTCP:LISTEN &>/dev/null || break
        sleep 0.25
      done
    fi
  done

  echo "Starting dashboard → http://localhost:5173"
  (cd "$ui_dir" && npm run dev) >>/tmp/superbot2-dashboard-ui.log 2>&1 &
  DASHBOARD_UI_PID=$!
  echo "Dashboard started (PID $DASHBOARD_UI_PID)"
}

stop_dashboard_ui() {
  if [[ -n "$DASHBOARD_UI_PID" ]]; then
    # Kill npm and all its child processes (concurrently, vite, node)
    pkill -P "$DASHBOARD_UI_PID" 2>/dev/null || true
    kill "$DASHBOARD_UI_PID" 2>/dev/null || true
    echo "Dashboard UI stopped."
    DASHBOARD_UI_PID=""
  fi
}

trap 'stop_dashboard_ui; rm -f "$LAUNCHER_PID_FILE"' EXIT

# ─── Subcommands ───

case "${1:-}" in
  update)
    exec bash "$REPO_DIR/scripts/update.sh"
    ;;

  setup)
    exec bash "$REPO_DIR/scripts/setup.sh"
    ;;

  imessage-setup)
    shift
    exec bash "$REPO_DIR/scripts/imessage-setup.sh" "${1:-setup}"
    ;;

  sync-app)
    # Sync dev repo to ~/.superbot2-app/ so the user can test the installed experience
    APP_DIR="${SUPERBOT2_APP_DIR:-$HOME/.${SUPERBOT2_NAME}-app}"
    echo ""
    echo "Syncing dev repo → $APP_DIR"
    echo ""

    mkdir -p "$APP_DIR"

    rsync -av --delete \
      --exclude '.git' \
      --exclude 'node_modules' \
      --exclude '.env' \
      --exclude '.env.*' \
      "$REPO_DIR/" "$APP_DIR/"

    echo ""
    echo "Installing dependencies..."
    if [[ -f "$APP_DIR/dashboard/package.json" ]]; then
      (cd "$APP_DIR/dashboard" && npm install --silent) && echo "  dashboard/ deps installed" \
        || echo "  WARNING: dashboard/ npm install failed"
    fi
    if [[ -f "$APP_DIR/dashboard-ui/package.json" ]]; then
      (cd "$APP_DIR/dashboard-ui" && npm install --silent) && echo "  dashboard-ui/ deps installed" \
        || echo "  WARNING: dashboard-ui/ npm install failed"
    fi

    echo ""
    echo "Building dashboard UI..."
    if (cd "$APP_DIR/dashboard-ui" && npm run build); then
      echo "  Build succeeded"
    else
      echo "  WARNING: Build failed — using pre-built dist/ from dev repo"
    fi

    # Sync git HEAD in app dir so the update checker shows "up to date"
    # (rsync doesn't touch .git, so HEAD would be stale without this)
    if [[ -d "$APP_DIR/.git" ]]; then
      git -C "$APP_DIR" fetch origin --quiet 2>/dev/null || true
      git -C "$APP_DIR" reset --mixed origin/main --quiet 2>/dev/null || true
      echo "  Git state synced"
    fi

    # Update alias to point to app dir (only — do NOT run setup.sh, it would
    # back up and overwrite the live ~/.superbot2 runtime data)
    echo ""
    echo "Updating shell alias..."
    SHELL_PROFILE=""
    if [[ "$SHELL" == *zsh* ]]; then SHELL_PROFILE="$HOME/.zshrc"
    elif [[ "$SHELL" == *bash* ]]; then SHELL_PROFILE="$HOME/.bashrc"; fi
    if [[ -n "$SHELL_PROFILE" ]]; then
      NEW_ALIAS="alias $SUPERBOT2_NAME=\"SUPERBOT2_NAME=$SUPERBOT2_NAME SUPERBOT2_HOME=$DIR $APP_DIR/superbot2\""
      if grep -q "alias $SUPERBOT2_NAME=" "$SHELL_PROFILE" 2>/dev/null; then
        sed -i '' "s|alias $SUPERBOT2_NAME=.*|$NEW_ALIAS|" "$SHELL_PROFILE"
        echo "  Updated alias → $APP_DIR/superbot2"
      else
        echo "" >> "$SHELL_PROFILE"
        echo "# $SUPERBOT2_NAME" >> "$SHELL_PROFILE"
        echo "$NEW_ALIAS" >> "$SHELL_PROFILE"
        echo "  Added alias → $APP_DIR/superbot2"
      fi
    fi

    echo ""
    echo "  ╔═══════════════════════════════════════════╗"
    echo "  ║          sync-app complete!               ║"
    echo "  ╚═══════════════════════════════════════════╝"
    echo ""
    echo "  App dir:  $APP_DIR"
    echo "  Data dir: $DIR"
    echo ""
    echo "  To test as an end user:"
    echo "    1. Restart your terminal (alias now points to $APP_DIR)"
    echo "    2. Run: $SUPERBOT2_NAME"
    echo ""
    echo "  To go back to dev mode:"
    echo "    Run: bash $REPO_DIR/scripts/setup.sh"
    echo "    Then restart your terminal."
    echo ""
    exit 0
    ;;

  help|--help|-h)
    echo "Usage: superbot2 [command]"
    echo ""
    echo "Commands:"
    echo "  (none)            Start the superbot2 orchestrator"
    echo "  update            Pull latest code and redeploy (preserves user data)"
    echo "  setup             Re-run initial setup"
    echo "  sync-app          Sync dev repo to ~/.superbot2-app/ for end-user testing"
    echo "  imessage-setup    Set up the iMessage bridge (also: status, test, reset)"
    echo "  help              Show this help"
    echo ""
    exit 0
    ;;
esac

# ─── Guard: run setup if not initialized ───

if [[ ! -d "$DIR" ]]; then
  echo "Superbot2 not set up yet. Running setup..."
  bash "$REPO_DIR/scripts/setup.sh"
fi

# ─── Assemble system prompt ───

assemble_prompt() {
  local prompt
  prompt=$(cat "$TEMPLATE")

  # Substitute identity
  if [[ -f "$DIR/IDENTITY.md" ]]; then
    local identity
    identity=$(cat "$DIR/IDENTITY.md")
    prompt="${prompt//\{\{IDENTITY\}\}/$identity}"
  else
    prompt="${prompt//\{\{IDENTITY\}\}/No identity configured yet.}"
  fi

  # Substitute user profile
  if [[ -f "$DIR/USER.md" ]]; then
    local user
    user=$(cat "$DIR/USER.md")
    prompt="${prompt//\{\{USER\}\}/$user}"
  else
    prompt="${prompt//\{\{USER\}\}/No user profile configured yet.}"
  fi

  # Substitute memory
  if [[ -f "$DIR/MEMORY.md" ]]; then
    local memory
    memory=$(cat "$DIR/MEMORY.md")
    prompt="${prompt//\{\{MEMORY\}\}/$memory}"
  else
    prompt="${prompt//\{\{MEMORY\}\}/No memory yet.}"
  fi

  # --- Pre-load context ---

  # Knowledge files
  local kfiles=("$DIR"/knowledge/*)
  if [[ ${#kfiles[@]} -gt 0 ]]; then
    prompt+=$'\n\n## Knowledge\n'
    for f in "${kfiles[@]}"; do
      [[ -f "$f" ]] || continue
      prompt+=$'\n### '"$(basename "$f")"$'\n\n'
      prompt+=$(cat "$f")
    done
  fi

  # Space configs
  local sfiles=("$DIR"/spaces/*/space.json)
  if [[ ${#sfiles[@]} -gt 0 ]]; then
    prompt+=$'\n\n## Spaces\n'
    for f in "${sfiles[@]}"; do
      [[ -f "$f" ]] || continue
      local slug
      slug=$(basename "$(dirname "$f")")
      prompt+=$'\n### '"$slug"$'\n\n```json\n'
      prompt+=$(cat "$f")
      prompt+=$'\n```\n'
    done
  fi

  # Pending escalations
  local pfiles=("$DIR"/escalations/pending/*.json)
  if [[ ${#pfiles[@]} -gt 0 ]]; then
    prompt+=$'\n\n## Pending Escalations\n'
    for f in "${pfiles[@]}"; do
      [[ -f "$f" ]] || continue
      prompt+=$'\n### '"$(basename "$f")"$'\n\n```json\n'
      prompt+=$(cat "$f")
      prompt+=$'\n```\n'
    done
  fi

  # Draft escalations
  local dfiles=("$DIR"/escalations/draft/*.json)
  if [[ ${#dfiles[@]} -gt 0 ]]; then
    prompt+=$'\n\n## Draft Escalations\n'
    for f in "${dfiles[@]}"; do
      [[ -f "$f" ]] || continue
      prompt+=$'\n### '"$(basename "$f")"$'\n\n```json\n'
      prompt+=$(cat "$f")
      prompt+=$'\n```\n'
    done
  fi

  # Substitute team name (last — catches placeholders in all appended content)
  prompt="${prompt//\{\{TEAM_NAME\}\}/$SUPERBOT2_NAME}"

  echo "$prompt"
}

# ─── Session ID ───

SESSION_FILE="$DIR/.orchestrator-session"
SESSION_ID=$(uuidgen | tr '[:upper:]' '[:lower:]')
echo "$SESSION_ID" > "$SESSION_FILE"
echo "Generated session ID: $SESSION_ID"

# Update team config with current session ID
if [[ -f "$TEAM_DIR/config.json" ]] && command -v jq &>/dev/null; then
  jq --arg sid "$SESSION_ID" '.leadSessionId = $sid' \
    "$TEAM_DIR/config.json" > "$TEAM_DIR/config.json.tmp" \
    && mv "$TEAM_DIR/config.json.tmp" "$TEAM_DIR/config.json"
fi

# ─── Main loop with restart support ───

rm -f "$RESTART_FLAG"
IS_RESTART=false

# Ensure heartbeat is running
if ! launchctl list com.superbot2.heartbeat &>/dev/null; then
  echo "Installing heartbeat..."
  bash "$REPO_DIR/scripts/install-heartbeat.sh"
fi

# Ensure scheduler is running
if ! launchctl list com.superbot2.scheduler &>/dev/null; then
  echo "Installing scheduler..."
  bash "$REPO_DIR/scripts/install-scheduler.sh"
fi

start_dashboard_ui

echo "Starting superbot2 orchestrator..."

while true; do
  # Assemble fresh context each iteration
  PROMPT=$(assemble_prompt)

  # Start watchdog: monitors for restart flag, kills claude when found
  (
    while true; do
      sleep 1
      if [[ -f "$RESTART_FLAG" ]]; then
        # Kill only the claude child process (NOT the launcher bash — that must stay alive to restart)
        pkill -TERM -P "$LAUNCHER_PID" 2>/dev/null || true
        # Wait 3 seconds then SIGKILL if still alive
        sleep 3
        pkill -KILL -P "$LAUNCHER_PID" 2>/dev/null || true
        exit 0
      fi
    done
  ) &
  WATCHDOG_PID=$!

  # Build claude args with team registration
  CLAUDE_ARGS=(
    --system-prompt "$PROMPT"
    --session-id "$SESSION_ID"
    --team-name "$SUPERBOT2_NAME"
    --agent-name team-lead
    --agent-id "team-lead@$SUPERBOT2_NAME"
    --dangerously-skip-permissions
  )

  if [[ "$IS_RESTART" == true ]]; then
    CLAUDE_ARGS+=(--resume "$SESSION_ID")
    INITIAL_MSG="Session restarted with fresh context. Begin your cycle."
  else
    INITIAL_MSG="Begin your cycle."
  fi

  # Purge self-addressed idle notifications from team-lead inbox
  # (Claude Code sends idle_notification to the team lead when any teammate's turn
  # ends — including the team lead itself, causing an infinite wake loop)
  INBOX="$TEAM_DIR/inboxes/team-lead.json"
  if [[ -f "$INBOX" ]] && command -v jq &>/dev/null; then
    jq '[.[] | select(.from != "team-lead" or ((.text // "") | test("idle_notification") | not))]' \
      "$INBOX" > "$INBOX.tmp" && mv "$INBOX.tmp" "$INBOX"
  fi

  # Trigger heartbeat to seed inbox
  bash "$REPO_DIR/scripts/heartbeat-cron.sh" &

  # || true: bypass set -e so bash continues to the restart check even when claude
  # exits with a non-zero code (e.g. 143 from SIGTERM). Without this, set -e would
  # kill the bash script before the restart loop runs.
  claude "${CLAUDE_ARGS[@]}" "$INITIAL_MSG" || true

  # Claude exited — clean up watchdog
  kill $WATCHDOG_PID 2>/dev/null
  wait $WATCHDOG_PID 2>/dev/null

  # Check if this was a restart request
  if [[ -f "$RESTART_FLAG" ]]; then
    rm -f "$RESTART_FLAG"
    IS_RESTART=true

    echo ""
    echo "Superbot2 restarting — resuming session $SESSION_ID"
    echo ""
    continue
  fi

  # Normal exit
  break
done

echo "Superbot2 orchestrator stopped."
